// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct ObjectDatum
{
	float4x4	LocalToWorldMatrix;
	int			IndicesOffset;
	int			IndicesCount;
};

static const float EPSILON = 1e-8;

int								_MaxSegments;
float4							_LightPosition;
float4							_LightForwardDir;
float4							_LightUpwardDir;
float							_InnerRange;
float							_OuterRange;
float							_SpotLightAngle;
float							_ShadowFocusDistance;
StructuredBuffer<ObjectDatum>	_ObjectData;
StructuredBuffer<float3>		_Vertices;
StructuredBuffer<int>			_Indices;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;


struct LightRay
{
	float3		Direction;
	float3		Color;
	float3		Position;
};

struct RayHit
{
	float3		Position;
	float		Distance;
	float3		Normal;
};

// Creates our inital light rays.
// uv: The uv position that the ray hits in the final texture result.
// halfSize: If we were to convert our resulting cookie texture to World-Space, this would be half its width (or height) at the given focus distance.
// lightRightwardDir: This is the light-source's Right Direction in World-Space. This value wasn't given to the shader, so it had to be computed.
LightRay CreateInitialLightRay(float2 uv, float halfSize, float4 lightRightwardDir)
{
	LightRay result;

	result.Color = float3(1.0, 1.0, 1.0);	// We will start with a pure white light, if the User wants to tint it, they can tint the actual light.
	result.Position = _LightPosition.xyz;	// Our starting position is the position of our light-source.

	// If we were to place our shadow texture in World-Space at the distance given by _ShadowFocusDistance, 
	// we want the offset vector that goes from our lightSource to our uv position. In other words, if we 
	// add this vector to our position, we will get a World-Space position that matches up to the given 
	// uv-position at the _ShadowFocusDistance.
	float3 hitPosOffset = (uv.x * halfSize) * lightRightwardDir.xyz;
	hitPosOffset += (uv.y * halfSize) * _LightUpwardDir.xyz;
	hitPosOffset += _ShadowFocusDistance * _LightForwardDir.xyz;

	// Normalize the offset we calculated into a direction vector.
	result.Direction = normalize(hitPosOffset);

	return result;
}

RayHit CreateRayHit()
{
	RayHit hit;

	hit.Position = float3(0.0f, 0.0f, 0.0f);
	hit.Distance = 1.#INF;
	hit.Normal = float3(0.0f, 0.0f, 0.0f);

	return hit;
}


bool IntersectTriangle_MT97(LightRay ray, float3 vert0, float3 vert1, float3 vert2, inout float t, inout float u, inout float v)
{
	// Find vectors for two edges sharing vert0
	float3 edge1 = vert1 - vert0;
	float3 edge2 = vert2 - vert0;

	// Begin calculating determinate - also used to calculate U parameter
	float3 pvec = cross(ray.Direction, edge2);

	// If determinant is near zero, ray lies in plane of triangle
	float det = dot(edge1, pvec);

	// use backface culling
	if (det < EPSILON)
		return false;

	float inv_det = 1.0f / det;

	// Calculate distance from vert0 to ray origin
	float3 tvec = ray.Position - vert0;

	// Calculate U parameter and test bounds
	u = dot(tvec, pvec) * inv_det;
	if (u < 0 || 1 < u)
		return false;

	// prepare to test V parameter
	float3 qvec = cross(tvec, edge1);

	// valculate V parameter and test bounds
	v = dot(ray.Direction, qvec) * inv_det;
	if (v < 0 || 1 < v)
		return false;

	// calculate t, ray intersects triangle
	t = dot(edge2, qvec) * inv_det;

	return true;
}

void IntersectMeshObject(LightRay lightRay, inout RayHit bestHit, ObjectDatum meshObject)
{
	uint offset = meshObject.IndicesOffset;
	uint count	= offset + meshObject.IndicesCount;

	for (uint i = offset; i < count; i += 3)
	{
		float3 v0 = (mul(meshObject.LocalToWorldMatrix, float4(_Vertices[_Indices[i + 0]], 1.0f))).xyz;
		float3 v1 = (mul(meshObject.LocalToWorldMatrix, float4(_Vertices[_Indices[i + 1]], 1.0f))).xyz;
		float3 v2 = (mul(meshObject.LocalToWorldMatrix, float4(_Vertices[_Indices[i + 2]], 1.0f))).xyz;

		float t, u, v;
		if (IntersectTriangle_MT97(lightRay, v0, v1, v2, t, u, v))
		{
			if (0 < t && t < bestHit.Distance)
			{
				bestHit.Distance	= t;
				bestHit.Position	= lightRay.Position + t * lightRay.Direction;
				bestHit.Normal		= normalize(cross(v1 - v0, v2 - v0));
			}
		}
	}
}

RayHit Trace(LightRay ray)
{
	RayHit bestHit = CreateRayHit();
	uint count, stride, i;

	_ObjectData.GetDimensions(count, stride);
	for (i = 0; i < count; i++)
	{
		IntersectMeshObject(ray, bestHit, _ObjectData[i]);
	}

	return bestHit;
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	uint width;
	uint height;

	Result.GetDimensions(width, height);

	float pixX = id.x + 0.5f;
	float pixY = id.y + 0.5f;

	float2 uv = float2(pixX / width, pixY / height);
	uv *= 2.0;
	uv -= 1.0;

	bool outOfBounds = dot(uv, uv) > 1.0;

	if (outOfBounds)
	{
		Result[id.xy] = float4(0.0, 0.0, 0.0, 0.0);
		return;
	}

	float4	lightRightwardDir	= float4(cross(_LightUpwardDir.xyz, _LightForwardDir.xyz), 0.0);
	float	halfSize			= _ShadowFocusDistance * tan(_SpotLightAngle);

	///
	/// Create inital LightRay for our Ray-Tracing.
	///
	LightRay lightRay = CreateInitialLightRay(uv, halfSize, lightRightwardDir);

	
	///
	/// Ray tracing code
	///
	for (int i = 0; i < _MaxSegments; i++)
	{
		RayHit hit = Trace(lightRay);
		if (hit.Distance < (2.0 * _OuterRange))
		{
			lightRay.Color *= 0.75f;
			lightRay.Direction = hit.Normal;
			lightRay.Position = hit.Position + (0.0005f * hit.Normal);
		}
		else
		{
			i = _MaxSegments;
		}
	}


	// If the light is pointing away from cookie-texture, then it can not add to the texture.
	if (dot(lightRay.Direction, _LightForwardDir.xyz) <= 0.0)
		return;

	/// 
	/// Convert our lightRay into a point on the plane that our Cookie will cover in World-Space at a 
	/// distance of _ShadowFocusDistance from our light-source
	///

	// This is uv-point (0, 0) in our plane.
	float3 v0			= (_ShadowFocusDistance * _LightForwardDir + _LightPosition).xyz;

	// This is the LightRay's current starting point.
	float3 p0			= lightRay.Position;


	// This is the delta vector from our LightRay's starting point to plane's 0-point.
	float3 W			= p0 - v0;
	
	// Normal vector for our plain
	float3 N			= (-_LightForwardDir).xyz;


	// This is the scale factor by which we multiple our lightRay's direction in order to find the offset 
	// for the intersection point
	float s_i			= dot(-N, W) / dot(N, lightRay.Direction);

	// This is our intersection point with the plane.
	float3 lightPoint	= (s_i * lightRay.Direction) + p0;

	///
	/// Convert our lightPoint in World-Space into a uv-coord.
	///
	float3	planeCoord = lightPoint - v0;
	float	uOffset = dot(planeCoord, lightRightwardDir.xyz);
	float	vOffset = dot(planeCoord, _LightUpwardDir.xyz);
	float2	uvPrime = float2(uOffset, vOffset);
	uvPrime *= (1.0 / halfSize);

	// Check to see if we're even in the allowed texture area.
	if (dot(uvPrime, uvPrime) > 1.0)
		return;

	float2 pix = uvPrime + 1.0;
	pix *= (1.0 / 2.0);
	pix *= width;

	int2 pixInt = pix;

	Result[pixInt.xy] += float4(1.0, 1.0, 1.0, 1.0);
}
