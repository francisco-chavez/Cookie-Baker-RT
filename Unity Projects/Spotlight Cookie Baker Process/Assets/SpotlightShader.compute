// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


static const float EPSILON = 1e-9;


struct BoundingBox
{
	float3		Position;
	float3		Extent;
};

struct ObjectMeshDatum
{
	int			IndicesOffset;
	int			IndicesCount;
	int			VerticesOffset;
	float4x4	LocalToWorldMatrix;
	BoundingBox BoundingBox;
};

struct LightRay
{
	float3		Direction;
	float3		Color;
	float3		Origin;
};

struct RayHit
{
	float3		Position;
	float		Distance;
	float3		Normal;
	bool		HasAHit;
};


float4								_UV_Offset;
float								_SampleCount;
int									_MaxSegments;
float								_ShadowFocusDistance;

float4								_LightPosition;
float4								_LightForwardDir;
float4								_LightUpwardDir;
float4								_LightRightwardDir;
float								_SpotLightAngleRad;

float								_InnerRange;
float								_OuterRange;

StructuredBuffer<ObjectMeshDatum>	_MeshObjectData;
StructuredBuffer<float3>			_Vertices;
StructuredBuffer<int>				_Indices;

RWTexture2D<float4>					_Result;


LightRay CreateInitialLightRay(float2 uv, float halfSize)
{
	LightRay lightRay;

	float3 originToShadowPlane = ((uv.x * halfSize) * _LightRightwardDir.xyz)
							   + ((uv.y * halfSize) * _LightUpwardDir.xyz)
							   + (_ShadowFocusDistance * _LightForwardDir);

	lightRay.Color		= float3(1.0f, 1.0f, 1.0f);
	lightRay.Origin		= _LightPosition.xyz;
	lightRay.Direction	= normalize(originToShadowPlane);

	return lightRay;
}

RayHit CreateRayHit()
{
	RayHit hit;

	hit.Position	= float3(0.0f, 0.0f, 0.0f);
	hit.Distance	= 1.#INF;
	hit.Normal		= float3(0.0f, 0.0f, 0.0f);
	hit.HasAHit		= false;

	return hit;
}

bool TriangleIntersect(LightRay lightRay, float3 vert0, float3 vert1, float3 vert2, out float s, out float3 n)
{
	s = 1.#INF;

	float3 edge0 = vert1 - vert0;
	float3 edge1 = vert2 - vert1;

	n = cross(edge0, edge1);

	float nDotLightRayDir = dot(n, lightRay.Direction);
	if (nDotLightRayDir > -EPSILON)
		return false;

	float3 p = lightRay.Origin;
	s = dot(-n, lightRay.Origin - vert0) / nDotLightRayDir;
	float3 intersectionPoint = (s * lightRay.Direction) + lightRay.Origin;

	float3 deltaFromLightSource = intersectionPoint - _LightPosition;
	float distFromLightSquared = dot(deltaFromLightSource, deltaFromLightSource);
	if (distFromLightSquared < (_InnerRange * _InnerRange))
		return false;
	if (distFromLightSquared < (_OuterRange * _OuterRange))
		return false;

	float3 c = cross(edge0, n);
	float3 delta = intersectionPoint - vert0;
	if (dot(delta, c) > 0.0f)
		return false;

	c = cross(edge1, n);
	if (dot(delta, c) < 0.0f)
		return false;

	c = cross((vert2 - vert1), n);
	delta = intersectionPoint - vert1;
	if (dot(delta, c) > 0.0f)
		return false;

	return true;
}

bool IntersectsBoundingBox(LightRay lightRay, BoundingBox boundingBox)
{
	return false;
}

RayHit Trace(LightRay lightRay)
{
	RayHit bestHit = CreateRayHit();
	uint objectCount, stride, i, j, subIndex0;

	_MeshObjectData.GetDimensions(objectCount, stride);

	for (i = 0; i < objectCount; i++)
	{
		ObjectMeshDatum objectDatum = _MeshObjectData[i];

		if (!IntersectsBoundingBox(lightRay, objectDatum.BoundingBox))
			continue;

		for (j = 0; j < objectDatum.IndicesCount; j += 3)
		{
			subIndex0 = j + objectDatum.IndicesOffset;

			float3 v0 = _Vertices[_Indices[subIndex0 + 0] + objectDatum.VerticesOffset];
			float3 v1 = _Vertices[_Indices[subIndex0 + 1] + objectDatum.VerticesOffset];
			float3 v2 = _Vertices[_Indices[subIndex0 + 2] + objectDatum.VerticesOffset];

			float4 v0_local = float4(v0, 1.0f);
			float4 v1_local = float4(v1, 1.0f);
			float4 v2_local = float4(v2, 1.0f);

			v0 = mul(objectDatum.LocalToWorldMatrix, v0_local).xyz;
			v1 = mul(objectDatum.LocalToWorldMatrix, v1_local).xyz;
			v2 = mul(objectDatum.LocalToWorldMatrix, v2_local).xyz;

			float s = 1.#INF;
			float3 n = float3(1.0f, 1.0f, 1.0f);

			bool theresAHit = TriangleIntersect(lightRay, v0, v1, v2, s, n);

			if (theresAHit)
			{
				if (0.0f < s && s < bestHit.Distance)
				{
					bestHit.Distance	= s;
					bestHit.Position	= lightRay.Origin + (s * lightRay.Direction);
					bestHit.Normal		= n;
					bestHit.HasAHit		= true;
				}
			}
		}
	}

	if (bestHit.HasAHit)
		bestHit.Normal = normalize(bestHit.Normal);

	return bestHit;
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
}
